listen:
  host: 127.0.0.1
  port: 3000

logLevel: info
WEBFORM_ALLOWED_ORIGINS:
  - https://tashi.namche.ai

agents:
  tashi:
    url: https://tashi.silverside-mermaid.ts.net
    openclawHooksToken: Bearer <OPENCLAW_HOOKS_TOKEN_TASHI>

apps:
  krisp:
    incomingAuthorization: Bearer <KRISP_AUTHORIZATION>
    targetAgent: tashi
    # OpenClaw hook parameters (hardwired in code, documented here for reference):
    # agentId: main              — which OpenClaw agent session to target
    # sessionKey: hook:notetaker:krisp — routes into the Krisp notetaker hook session
    # wakeMode: next-heartbeat   — processed at the next heartbeat, not urgently
    # deliver: false             — queued silently; no immediate notification pushed

  # gmail is optional — omit to disable the route
  # Single endpoint handles two legs of the Gmail pipeline:
  #
  # Leg 1 — Google Pub/Sub → api-proxy → gog gmail watch serve
  #   Google sends OIDC JWT; proxy verifies and forwards raw body to forwardUrl (gog).
  #
  # Leg 2 — gog gmail watch serve → api-proxy → OpenClaw
  #   gog sends processed payload (messages + labels) with hookToken auth.
  #   Proxy filters for Label_15 + INBOX (!SENT), then forwards to hookUrl (OpenClaw).
  #   Set gog: --hook-url https://api.namche.ai/v1/webhooks/agents/tashi/gmail
  #            --hook-token <same as hookToken below>
  gmail:
    oidcEmail: <SERVICE_ACCOUNT>@<PROJECT>.iam.gserviceaccount.com  # expected GCP SA in OIDC JWT
    targetAgent: tashi
    forwardUrl: https://tashi.silverside-mermaid.ts.net/gmail-pubsub?token=<GOG_SERVE_TOKEN>
    hookToken: <SHARED_TOKEN>          # shared secret — set as gog --hook-token
    hookUrl: https://tashi.silverside-mermaid.ts.net/hooks/gmail  # OpenClaw hooks endpoint
